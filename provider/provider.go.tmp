package provider

import (
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/internal/provider"
	"log"
)

var azProvider = provider.AzureProvider()

func getRootSchema(rootBlockName string, rootBlockType RootBlockType) map[string]*schema.Schema {
	blockNameNotValid := false
	if rootBlockType == Provider {
		if rootBlockName == "azurerm" {
			return azProvider.Schema
		}
		blockNameNotValid = true
	} else if rootBlockType == Resource {
		if _, ok := azProvider.ResourcesMap[rootBlockName]; ok {
			return azProvider.ResourcesMap[rootBlockName].Schema
		}
		blockNameNotValid = true
	} else if rootBlockType == DataSource {
		if _, ok := azProvider.DataSourcesMap[rootBlockName]; ok {
			return azProvider.DataSourcesMap[rootBlockName].Schema
		}
		blockNameNotValid = true
	}
	if blockNameNotValid {
		log.Printf("[WARN] no such %s with block name `%s`!", rootBlockType, rootBlockName)
		return nil
	}
	log.Printf("[WARN] block type `%s` not supported!", rootBlockType)
	return nil
}

// GetArgSchema the first elem in blockNameSeq is rootBlockType, followed by the sequence of parent block names
func GetArgSchema(blockNameSeq []string) map[string]*schema.Schema {
	if len(blockNameSeq) < 2 {
		log.Printf("[DEBUG] there must be at least 2 elements in blockNameSeq (rootBlockType, rootBlockName)")
	}
	input := getRootSchema(blockNameSeq[1], RootBlockType(blockNameSeq[0]))
	return getNestedArgSchema(blockNameSeq, input, 2)
}

func getNestedArgSchema(blockNameSeq []string, input map[string]*schema.Schema, index int) map[string]*schema.Schema {
	if index > len(blockNameSeq) {
		return nil
	} else if index == len(blockNameSeq) {
		return input
	} else {
		field, ok := input[blockNameSeq[index]]
		if !ok {
			log.Printf("[DEBUG] `%s` is not the inner block of %s", blockNameSeq[index], blockNameSeq[:index])
			return nil
		}
		innerSchema := getInnerArgSchema(field)
		if innerSchema == nil {
			log.Printf("[DEBUG] innerSchema read failed for %s", blockNameSeq[:index+1])
			return nil
		}
		return getNestedArgSchema(blockNameSeq, innerSchema, index+1)
	}
}

func getInnerArgSchema(field *schema.Schema) map[string]*schema.Schema {
	if field.Computed && !(field.Optional || field.Required) {
		return nil
	}
	if field.Type != schema.TypeList && field.Type != schema.TypeSet {
		return nil
	}
	if field.Elem == nil {
		return nil
	}
	v, ok := field.Elem.(*schema.Resource)
	if !ok {
		return nil
	}
	if v == nil {
		return nil
	}
	return v.Schema
}